
Registers:
RA - Accumulator
RB - Register B
PA - Pointer accumulator - generally transient addresses
PB - Pointer B           - generally a longer-lived context structure
PC - Program counter
LR - Link register
CF - Carry flag

# Imm4 instructions
IMM:  RA <- imm4             # Immediate
LAE:  RA <- [PA+RB+imm4]     # Load A element
LAF:  RA <- [PA+imm4]        # Load A field
LBF:  RA <- [PB+imm4]        # Load B field
SAE:  [PA+RB+imm4] <- RA     # Store A element
SAF:  [PA+imm4] <- RA        # Store A field
SBF:  [PB+imm4] <- RA        # Store B field
PAF:  PA <- [PA+imm4]        # Pointer A field
PAE:  PA <- [PA+RB+imm4]     # Pointer A element
PBF:  PA <- [PB+imm4]        # Pointer B field
AP:   PA <- PA + imm4        # Advance pointer
SPBF: [PB+imm4] <- PA        # Store pointer
SCC:  PC <- PC + imm4        # Skip if carry clear
SCS:  PC <- PC + imm4        # Skip if carry set

# Opcode-only instructions
RX:   RA <-> RB             # Register exchange
PX:   PA <-> PB             # Pointer exchange
AX:   RA <-> PA             # Register-pointer accumulator exchange
LPX:  PA <-> LR
RA2B: RB <- RA
PB2A: PA <- PB
P2R:  RA <- PA
C2A:  RA <- CF
CLn:  (0-3)                 # Carry if RA < n
CLEB:                       # Carry if RA <= RB
CLEBC:                      # Carry if RA <= RB - carry
CLB:                        # Carry if RA < RB
SUB
SBC
ADC
ADD
LINKn: LR := PC+n
SPLIT
PADD:  PA <- PA + RB
JP:    PC <- PA
RET:   PC <- LR
LSR:   Logical shift right RA by signed # bits in RB: 0-7 = right, 8-15 = left


### Meta interpreter ###

	# Simulated registers
	R_PC	equ 0
	R_PA	equ 1
	R_PB	equ 2
	R_RA	equ 3
	R_RB	equ 4
	R_LR	equ 5
	R_CF	equ 6

	# Handler tables
	H_MAIN	equ 9	# Main handlers
	H_AX	equ 10	# Ax handlers
	H_BX	equ 11	# Bx handlers

	# Vector table
	V_MAIN	equ 12  # MAIN_LOOP
	V_RET	equ 13  # MAIN_RETURN
	V_ALU	equ 14	# PREP_ALU_REGS
	V_CARRY	equ 15	# SET_CARRY_AND_RETURN
	
	.org 0x20
MAIN_LOOP:
	# PB points to context
	PBF	R_PC
	LAF	0	# Load instruction
	AP	1
	SPBF	R_PC	# Advance PC
	SPLIT
	LSR	4
	RX		# RA = lo4, RB = hi4
	PAF	H_MAIN
	PAE	0	# PA = handler address
	XCHG		# RA = hi4, RB = lo4
	LINK	1
	JP
MAIN_RETURN:
	# Return from handler
	PBF	V_MAIN
	JP

PREP_ALU_REGS: # Subroutine to load interpreter RA, RB, CF into actual cpu registers
	LBF	F_CF
	RX
	IMM	0
	CLB		# CF is loaded
	LBF	F_RB
	RX
	LBF	F_RA	# RA and RB loaded
	RET

SET_CARRY_AND_RETURN:
	C2A
	SBF	F_CF
	PBF	V_RET
	JP

O_IMM:
	PB2A
	SAF	F_RA
	RET

O_LAE: # UNUSED
	LBF	F_PA
	ADD
	RX		# RB is PA+imm4
	PBF	F_RB	# PA is RB
	PAE		# PA is [PA+RB+imm4]
	SPBF	F_RA
	RET
	
O_LAF: # USED ONCE
	PBF	F_PA
	PAE		# PA is [PA+imm4]
	SPBF	F_RA
	RET
	
O_SAE: # UNUSED
	LBF	F_PA
	ADD		# RA is PA+imm4
	RX		# RB is PA+imm4
	PBF	F_RB	# PA is RB
	LBF	F_RA
	SAE	0	# Store to [PA+RB+imm4]
	RET

O_SAF:
	PBF	F_PA
	LBF	F_RA
	SAE	0	# Store to [PA+imm4]
	RET

O_PAF:
	PBF	F_PA
	LBF	F_PA
	SAE	0	# Store to [PA+imm4]
	RET

O_PAE:
	LBF	F_PA
	ADD		# RA is PA+imm4
	RX		# RB is PA+imm4
	PBF	F_RB	# PA is RB
	LBF	F_PA
	SAE	0	# Store to [PA+RB+imm4]
	RET
	
O_LBF:
	PBF	F_PB
	PAE		# PA is [PB+imm4]
	SPBF	F_RA
	RET
	
O_PBF:
	PBF	F_PB
	PAE		# PA is [PB+imm4]
	SPBF	F_PA
	RET
	
O_AP:
	PBF	F_PA
	PADD
	SPBF	F_PA
	RET

O_SBF:
	PBF	F_PB
	LBF	F_RA	# RA is RA
	SAE	0	# Store to [PB+imm4]
	RET

O_SPBF:
	PBF	F_PB
	LBF	F_PA	# RA is PA
	SAE	0	# Store to [PB+imm4]
	RET

O_SCC:
	LBF	F_CF
	CL	1
	SCS	3	# Ironic
	PBF	F_PC
	PADD
	SPBF	F_PC
	RET

O_SCS:
	LBF	F_CF
	CL	1
	SCC	3	# Ironic
	PBF	F_PC
	PADD
	SPBF	F_PC
	RET

O_RX:
	LBF	F_RA
	PBF	F_RB
	SPBF	F_RA
	SBF	F_RB
	RET

O_PX:
	LBF	F_PA
	PBF	F_PB
	SPBF	F_PA
	SBF	F_PB
	RET

O_AX: # UNUSED
	LBF	F_PA
	PBF	F_RA
	SPBF	F_PA
	SBF	F_RA
	RET

O_LPX:
	LBF	F_PA
	PBF	F_LR
	SPBF	F_PA
	SBF	F_LR
	RET

O_RA2B:
	LBF	F_RA
	SBF	F_RB
	RET

O_PB2A:
	LBF	F_PB
	SBF	F_PA
	RET

O_P2R:
	LBF	F_PA
	SBF	F_RA
	RET

O_CL:
	LBF	F_RA
	CLB		# B contains the imm4
	PBF	V_CARRY
	JP

O_CLEB:
	PBF	V_ALU
	JP
	CLEB
	PBF	V_CARRY
	JP

O_CLEBC:
	PBF	V_ALU
	JP
	CLEBC
	PBF	V_CARRY
	JP

O_CLB:
	PBF	V_ALU
	JP
	CLB
	PBF	V_CARRY
	JP

O_SUB:
	PBF	V_ALU
	JP
	SUB
	SBF	F_RA
	PBF	V_CARRY
	JP

O_SBC:
	PBF	V_ALU
	JP
	SBC
	SBF	F_RA
	PBF	V_CARRY
	JP

O_ADC:
	PBF	V_ALU
	JP
	ADC
	SBF	F_RA
	PBF	V_CARRY
	JP

O_ADD:
	PBF	V_ALU
	JP
	ADD
	SBF	F_RA
	PBF	V_CARRY
	JP

O_LINK:
	LBF	F_PC
	ADD
	SBF	F_LR
	RET

O_SPLIT:
	PBF	V_ALU
	JP
	SPLIT
	SBF	F_RA
	RX
	SBF	F_RB
	RET

O_PADD:
	LBF	F_RB
	RX
	LBF	F_PA
	ADD
	SBF	F_PA
	RET

O_JP:
	LBF	F_PA
	SBF	F_PC
	RET

O_RET:
	LBF	F_LR
	SBF	F_PC
	RET

O_LSR:
	PBF	V_ALU
	JP
	LSR
	SBF	F_RA
	RET

AX_TRAMPOLINE:
	PBF	H_AX
	PAE	0
	JP

BX_TRAMPOLINE:
	PBF	H_BX
	PAE	0
	JP

MAIN_HANDLERS:
	IMM	O_IMM
	IMM	O_LAE
	IMM	O_LAF
	IMM	O_SAE

	IMM	O_SAF
	IMM	O_PAF
	IMM	O_PAE
	IMM	O_PBF

	IMM	O_AP
	IMM	O_SPBF
	IMM	AX_TRAMPOLINE
	IMM	BX_TRAMPOLINE

	IMM	O_SCC
	IMM	O_SCS
	IMM	0xFF
	IMM	0xFF

AX_HANDLERS:
	IMM	O_LINK
	IMM	O_LINK
	IMM	O_LINK
	IMM	O_LINK

	IMM	O_PX
	IMM	O_LPX
	IMM	O_SBC
	IMM	O_SUB

	IMM	O_C2A
	IMM	O_RX
	IMM	O_AX   # aa
	IMM	O_RA2B # ab

	IMM	O_ADC
	IMM	O_ADD
	IMM	O_PADD
	IMM	O_AP

BX_HANDLERS:
	IMM	O_CL
	IMM	O_CL
	IMM	O_CL
	IMM	O_CL

	IMM	O_RET # b4
	IMM	O_CLEB
	IMM	O_CLEBC
	IMM	O_CLB

	IMM	O_P2R
	IMM	O_LPX
	IMM	O_PB2A # ba
	IMM	O_PX

	IMM	O_JP
	IMM	O_LSR
	IMM	0XFF
	IMM	O_SPLIT # bf - needs to end in an f


	# Initialization
	.org	0x00
	# Registers
	IMM	0x10	# Initial PC
	IMM	0
	IMM	0
	IMM	0

	IMM	0
	IMM	0
	IMM	0
	IMM	0

	IMM	0
	IMM	MAIN_HANDLERS
	IMM	AX_HANDLERS
	IMM	BX_HANDLERS

	IMM	MAIN_LOOP
	IMM	MAIN_RETURN
	IMM	PREP_ALU_REGS
	IMM	SET_CARRY_AND_RETURN


